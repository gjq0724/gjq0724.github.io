<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bioperl安装(无需root权限)]]></title>
    <url>%2Fbioperl%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[###bioperl 安装（cpan）1) perl -MCPAN -e shell 一路回车，安装完成后q退出1234567source ~/.bashrc&gt;cpancpan&gt;install Module::Buildcpan&gt;o conf prefer_installer MBcpan&gt;o conf commitcpan&gt;q 2) 下载bioperl(wget https://github.com/bioperl/bioperl-live/archive/master.zip)并解压：unzip master.zip3) 进入解压后的目录安装123 perl Build.PL --install_base=~/perl5/Bioperl/ 指定安装目录，可自行修改./Build test./Build install 中间一直敲回车即可，若无报错，则安装完成 ##blastxml安装1) 下载blastxml(wget http://search.cpan.org/CPAN/authors/id/C/CJ/CJFIELDS/Bio-SearchIO-blastxml-1.70.tar.gz)并解压2) 进入解压后的目录安装123perl Makefile.PL --install_base ~/perl/lib/perl/Bio/SearchIO/make make install]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>bioperl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vcftools]]></title>
    <url>%2Fvcftools%2F</url>
    <content type="text"><![CDATA[vcftools 安装与使用安装###获取vcftools软件包12wget https://ncu.dl.sourceforge.net/project/vcftools/vcftools_0.1.13.tar.gztar -zxvf vcftools_0.1.13.tar.gz ###安装vcftools123cd vcftools_0.1.13.tar.gzmakemake install ##使用 ###参考链接（http://vcftools.sourceforge.net/man_latest.html#DESCRIPTION)Output allele frequency for all sites in the input vcf file from chromosome 11vcftools --gzvcf input_file.vcf.gz --freq --chr 1 --out chr1_analysis Output a new vcf file from the input vcf file that removes any indel sites 1vcftools --vcf input_file.vcf --remove-indels --recode --recode-INFO-all --out SNPs_only Output file comparing the sites in two vcf files 1vcftools --gzvcf input_file1.vcf.gz --gzdiff input_file2.vcf.gz --diff-site --out in1_v_in2 Output a new vcf file to standard out without any sites that have a filter tag, then compress it with gzip 1vcftools --gzvcf input_file.vcf.gz --remove-filtered-all --recode --stdout | gzip -c &gt; output_PASS_only.vcf.gz Output a Hardy-Weinberg p-value for every site in the bcf file that does not have any missing genotypes 1vcftools --bcf input_file.bcf --hardy --max-missing 1.0 --out output_noMissing Output nucleotide diversity at a list of positions 1zcat input_file.vcf.gz | vcftools --vcf - --site-pi --positions SNP_list.txt --out nucleotide_diversity]]></content>
      <tags>
        <tag>vcftools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blast+安装与使用]]></title>
    <url>%2Fblast%2B%2F</url>
    <content type="text"><![CDATA[blast+ 安装与使用NCBI 的 blast软件是做生物信息学分析最常用的工具之一，是用C语言编写的。随着技术的发展，NCBI于09年发布了blast的升级版本blast+，并强烈建议放弃blast。blast+使用了blast的核心算法，延续了blast的优势功能，同事在运算速度上有了很大的提升。在此介绍一下linux系统下blast+的配置与使用方法，以供大家参考。 安装配置blast+程序总体来说，blast+的安装配置是比较容易的，可以在在ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/中下载最新的BLAST+可执行程序，在服务器联网的情况下，也可以通过以下命令下载： 1wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/ncbi-blast-2.6.0+-x64-linux.tar.gz 下载完成后，在服务器上进行解压： 12tar -zxvf ncbi-blast-2.6.0+-x64-linux.tar.gzmv ncbi-blast-2.6.0+ ~/blast+ 接下来就是配置环境变量，将解压后的文件夹移动到当前用户根目录下（高级玩家可以不用移动，在此只是为了方便配置环境变量），并添加到当前用户的环境变量配置文件中 1vi ~/.bashrc 在.bashrc文件中添加以下内容： 1export PATH="~/blast+/bin:$PATH" 保存并退出后更新一下环境变量： 1source ~/.bashrc 配置完成后可以用以下命令验证并查看一下当前blast+版本信息： 1blastx -version blast+的使用 格式化数据库 将本地的核酸或者蛋白数据库格式化创建索引 1makeblastdb -in db.fasta -dbtype nucl -parse_seqids -out dbname ​ 参数说明： ​ -in:待格式化的数据库文件 ​ -dbtype: 数据库类型，prot或nucl ​ -out:数据库名 ​ 比如建立ncbi蛋白数据库，可以使用以下命令： 1makeblastdb -in nr.fasta -dbtype prot -parse_seqids -out nr 数据库比对 核酸序列比对到核酸数据库（blastn） 1blastn -query seq.fa -out seq.blast -db dbname -outfmt 6 -evalue 1e-10 -num_descriptions 10 -num_threads 8 核酸序列比对到蛋白数据库（blastx） 1blastx -query seq.fa -out seq.blast -db dbname -outfmt 6 -evalue 1e-10 -num_descriptions 10 -num_threads 8 蛋白序列比对到蛋白数据库（blastp） 1blastp -query seq.fa -out seq.blast -db dbname -outfmt 6 -evalue 1e-10 -num_descriptions 10 -num_threads 8 参数说明： -query: 输入文件路径及文件名 -out：输出文件名 -db: 格式化了的数据库 -outfmt: 输出文件格式，共有十二种格式，其中 6 是blast对应的-m 8格式 -evalue: 设置输出结果的阈值 -num_descriptions: 输出结果的个数 -num_threads: 使用线程数量 ​ ​ 如有问题，欢迎交流！]]></content>
      <categories>
        <category>software</category>
      </categories>
      <tags>
        <tag>blast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rose-seqtar]]></title>
    <url>%2Frose-seqtar%2F</url>
    <content type="text"><![CDATA[运行seqtar程序seqtar的运行需要三个文件，分别是cDNA文件，保守miRNA做的序列文件（fa格式），以及降解组数据通过small-rna分析生成的tissue-freq文件，具体脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146################################################################################## The SeqTar pipeline - predict miRNA/siRNA targets from degradomes## 2010 - 2011## last update: May 30, 2011# # All rights reserved by Yun ZHENG (zhengyun@fudan.edu.cn)## Please read the license.txt before you use the SeqTar pipeline. # Contact Dr. Yun Zheng to obtain a license if you do not have one.## Yun Zheng# Institute of Developmental Biology and Molecular Medicine# Fudan University# Yifu Bldg of Science and Tech., 220 Handan Road# Shanghai, China 200433# zhengyun@fudan.edu.cn# # This software has NO WARRANTY. The author and Fudan University have NO# responsibility on the consequences of using the software.#################################################################################################################################################################### 2. Required programs:# 2.1. Before your run SeqTar, you should make sure the following packages have been# installed in your system.# 2.1.1 Java version 1.6.0 or newer version# Read http://www.java.com/en/download/help/linux_install.xml for Java and # a manual of installation.# 2.1.2 NCBI SOAP2 or BLAST (see the script for BLAST users)# To obtain BLAST, visit ftp://ftp.ncbi.nlm.nih.gov/blast/executables/release/LATEST/# To obtain SOAP2, visit http://soap.genomics.org.cn/soapaligner.html# 2.1.3 The tcsh shell.################################################################################################################################################################### 3. Input files:# In this script, suppose your degradome file is named as degradome.fa, # the cDNA sequence file is named as all.cDNA, and# the miRNA/siRNA sequence file is name as miRNA.fa.# 3.1 Format of degradome.fa# The degradome unique reads file should follow a special fasta format such that# the frequency of unique sequence is placed after the ID of the read, separated # with a space. An example is# &gt;r0001 20# ACCATTCGGAGTCGAAGCGT# &gt;r0002 12# TCCACGCGGATGGTCGGCGT# where the read r0001, ACCATTCGGAGTCGAAGCGT, has appeared 20 times in the degradome# data set, and so on.# 3.2 The format of all.cDNA# There are no requirements for the format of cDNA sequences. But the IDs of# cDNA sequences should be unique, where .1, .2 etc will be used to indicate# the splicing variants from the same locus.# It is better to have the annotation of the cDNA after its ID. These annotation# information will be given in the output files if there are provide in the cDNA# sequence files.# 3.3 The miRNA sequence file# Although not required, it is highly suggested to combined miRNA/siRNAs that# have the same mature miRNA/siRNA sequences into one entry in the fle of miRNA# sequences.# 3.4 How to use this script# under Linux OS, bash shell, type this line below and return.# $nohup tcsh seqtar-pipeline-soap.sh &amp; ################################################################################################################################################################### 4. Step 0, split the raw degradome reads, degradome.fa, to separate files with 1M reads.# NOTE: You should make sure there are no files with the extension of fasta.# Make sure to place JSmallRNA.jar and your input files mentioned in Section 3 in# the same folder.java jsmallrna.mirna.SplitFastaFile -i degradome.fa -n 100000 -o separated_deg.fasta################################################################################################################################################################### 5. Step 1, align raw degradome reads, separated_deg.fasta, to cDNA sequences, all.cDNA# 5.1 This is to build the index file that will be used by SOAP2.#2bwt-builder all.cDNA# 5.2 This is to align degradome reads to cDNA with SOAP2.foreach FASTA (*.fasta)soap -a $FASTA -D /mnt/S30/guojq/rose/rose-degradome/rose-leaf-degradome/seqtar/all.cDNA.index -o `\basename $FASTA .fasta`-vs-cdna.soap -M 0 -r 2 -u `\basename $FASTA .fasta`-unmapped.faend# where `\basename $FASTA .fasta` will be a file that contains unaligned degradome reads.################################################################################################################################################################### 6. Step 2, normalize the reads according to their hits in the cDNA sequencesforeach FASTA (*.fasta)java jsmallrna.seqtar.NormalizeReadSOAP -i $FASTA -s `\basename $FASTA .fasta`-vs-cdna.soap -o `\basename $FASTA .fasta`.normend################################################################################################################################################################### 7. Step 3, concatenate all normalized reads and align the normalized reads to the cDNA sequencescat *.norm &gt; all_norm.fasoap -a all_norm.fa -D /mnt/S30/guojq/rose/rose-degradome/rose-leaf-degradome/seqtar/all.cDNA.index -o all-norm-vs-cdna.soap -M 0 -r 2 -u all-norm-unmapped.fa################################################################################################################################################################### 8. Step 4, sort the blast results according to the IDs of cDNAssort -k 8 all-norm-vs-cdna.soap &gt; all-norm-vs-cdna-sorted.soap################################################################################################################################################################### 9. Step 5, the main SeqTar step# 9.1 This step is to split the miRNA file to small segments.#java jsmallrna.mirna.SplitFastaFile -i miRNA.fa -n 20 -o uniq-miRNA.separated# 9.2 This is the main step of SeqTarforeach SEP_MIR (*.separated)java jsmallrna.seqtar.SeqTarSOAP -t /mnt/S30/guojq/rose/rose-degradome/rose-leaf-degradome/seqtar/all.cDNA -i $SEP_MIR -b ../all-norm-vs-cdna-sorted.soap -l 20 -p 100 -o `\basename $SEP_MIR .separated`-cdna.seqtar -s 60 -a 0.1 -m 0.1 &gt; `\basename $SEP_MIR .separated`-vs-cdna.logend# 9.3 The output of this step# This step will produce the following files. See Supplementary Methods for more # details.# 9.3.1 The file miRNA-cdna-mir-cand.txt listed the miRNA/siRNA candidates. # 9.3.2 The miRNA-cdna-reads-distr.m contained matlab scripts to generate T-plots # for all targets.# 9.3.3 The miRNA-cdna-shuffled-scores.txt file contained the scores of shuffled # sRNA sequences for each of the inputted sRNAs.# 9.3.4 The miRNA-cdna-total-reads.txt file contained the total number of reads # that were perfectly matched to each transcript sequences in the file all.cDNA.# 9.3.5 The miRNA-cdna-unique.txt file listed the unique sRNA:target pairs.# 9.3.6 The miRNA-cdna.seqtar file were the full results, with all sRNA:target # alignments and the number of reads corresponding to each site.# 9.3.7 The miRNA-vs-cdna.log is a log of computing process.################################################################################################################################################################### 10. Step 6, this is an additional step to remove the redundant miRNA:target pairs # in the miRNA-cdna-unique.txt file.#cat *unique.txt &gt; miRNA-cdna-unique.original#grep "@@" miRNA-cdna-unique.original &gt; miRNA-cdna-pairs.txt#sed 's/@@\t//g' miRNA-cdna-pairs.txt &gt; miRNA-cdna-pairs-trimmed.txt#sed 's/Query/#Query/g' miRNA-cdna-pairs-trimmed.txt &gt; miRNA-cdna-pairs-trimmed.replaced# 10.1 This step is to remove the duplicate miRNA:target pairs that caused by# different members of the same miRNA family, and different splicing variants# of the same gene.#java -cp ./JSmallRNA.jar jsmallrna.mirna.RetrieveMiRTargetFamily -i miRNA-cdna-pairs-trimmed.replaced -o miRNA-cdna-family.txt -u miRNA-cdna.uniq# 10.2 This step is to remove the redundant miRNA:target pairs. A miRNA:target pair# is definied as a redundant miRNA pair if i) the miRNA binds to the same site# or has less than or equal to 2 nt shift from a site of the other miRNA; ii) # the complementary site of this miRNA has more mismatches than the other miRNA's.#java -cp ./JSmallRNA.jar jsmallrna.mirna.RemoveRedundantMiRTarget -i miRNA-cdna.uniq -o miRNA-cdna-family-total.txt -u miRNA-cdna-no-redundant.txt################################################################################# 整理seqtar结果，画t-plots图根据seqtar结果，得到m文件以及alignment文件 1234567891011121314151617181920212223242526272829303132# 需要准备的文件：==&gt; 首先是准备 miRNA 的 ID 和 REF 的 ID，就是 seqtar 的最后一步的 redundant 的文件的前三列，命名为 miRNA-seqtar-message.txt# 程序主要功能，将绘制 t-plots 的文件进行整理，整理结果是每一个 miRNA 所对应的 Ref 位点和绘制 t-plots 图的matlab文件放在一个目录下，目录名称为 ”miRNA名称_Ref_位点名称“# 检查 miRNA 的文件的重复，需要 unique 的 miRMA ID (文件 miRNA.fa 不能有重复的 ID )# 注意！！！ ==&gt; 该脚本是针对每一个 miRNA 只有一个靶点进行摘取信息。当 miRNA 有多个的 Ref 的靶点的时候（即第三列的数值 &gt; 1 ）,该情况下的 miRNA 信息会被导出到文件 “more-than-one-Ref.txt” 中，需要手动摘取信息。# 使用方式： # 1、在 seqtar 第九步（step9）目录下，新建一个文件夹，命名 t-plots# 2、将脚本和准备好的文件 miRNA-seqtar-message.txt 放在该目录下# 2、sh t-plots.sh &amp; &gt; sh.logs=`wc -l seqtar-message.txt | awk '&#123;print $1&#125;'`for (( i=1; i&lt;=s; i=i+1 ))do Query=$(sed -n "$i"p seqtar-message.txt | awk '&#123;print $1&#125;') Ref=$(sed -n "$i"p seqtar-message.txt | awk '&#123;print $2&#125;') Var=$(sed -n "$i"p seqtar-message.txt | awk '&#123;print $3&#125;') if [ $Var -eq 1 ] then FileNum=$(grep $Query ../run*/*ed | awk -F "[/,:]" '&#123;print $3&#125;' | tr -cd [0-9]) RunNum=$(grep $Query ../run*/*ed | awk -F "[/]" '&#123;print $2&#125;' | tr -cd [0-9])# cd ../run$RunNum mkdir "$Query"_Ref_"$Ref" grep -w "$Query on Ref: $Ref" ../run$RunNum/uniq-miRNA$FileNum-cdna.seqtar -A 10 -B 1 &gt; ./"$Query"_Ref_"$Ref"/"$Query"_Ref_"$Ref".txt grep "$Ref" ../run$RunNum/uniq-miRNA$FileNum-cdna-reads-distr.m -A 3 | sed '$d' |sed 's/\.jpeg/\.jpg/g' |sed 's/|/\_/g' |sed '/XLabel/s/\_/\\_/g' |sed '/title/s/\_/\\_/g' &gt; ./"$Query"_Ref_"$Ref"/"$Query"_Ref_"$Ref".m else sed -n "$i"p seqtar-message.txt &gt;&gt; more-than-one-Ref.txt fidone 修改alignment文件，交换Query行与Ref行，并修改每个文件中的Ref与Query： 12345678910111213141516#!/bin/bashfor file in `ls *.txt`do lines=`wc -l $file|awk '&#123;print $1&#125;'` filename=$file if [ $lines -eq 12 ] then sed -i '/$query/&#123;:a;N;/Ref/!ba;/[^\n]*$query[^\n]*\n[^\n]*Ref[^\n]*$/&#123;s/\([^\n]*$query[^\n]*\)\n\(.*\)/\2\n\1/;&#125;;s/\([^\n]*\)\n\(.*\)\n\(.*\)/\3\n\2\n\1/&#125;' $file query=`sed -n '5p' $file |cut -f 2` ref=`sed -n '5p' $file |cut -f 3` sed -i "s/Ref\./$ref/g" $file sed -i "s/Query/$query/g" $file else echo $file "need to change manually" fidone 讲m文件放到matlab中画图]]></content>
      <categories>
        <category>项目随笔</category>
      </categories>
      <tags>
        <tag>rose</tag>
        <tag>seqtar</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO--tair10(methylation)]]></title>
    <url>%2FGO-tair10-methylation%2F</url>
    <content type="text"><![CDATA[找甲基化差异表达基因上下游5000bp的基因 对methylKit得到的甲基化区域进行处理，得到差异表达区域上下游5000bp包含的基因（/mnt/S30/guojq/methylation/diff-region/bedtools) ​ 123456789#1.make gff fileforeach GTF(../*.gtf)awk '&#123;print $1"\t"$2"\t"$3"\t"$4-5000"\t"$5+5000"\t"$6"\t"$7"\t"$8"\t"$9&#125;' $GTF &gt;`\basename $GTF .gtf`.gff3end#2.bedtools alignforeach GFF(*.gff3)intersectBed -a tair10.gff -b $GFF |grep 'gene' |sort |uniq -f 5 &gt;`\basename $GFF .gff3`_gene.gffend 获取差异表达区域上下游5000bp包含的基因序列 对上一步得的基因取序列： 12345foreach GFF(*.gff)sed -i 's/gene/exon/g' $GFFsed -i 's/=/:/g' $GFFgffread $GFF -g tair10.fa -w `\basename $GFF .gff`.faend ​ 3.将得到的序列放到Kobas 3.0 上运行，进行GO分析]]></content>
      <categories>
        <category>项目随笔</category>
      </categories>
      <tags>
        <tag>tair10 GO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rose-phas]]></title>
    <url>%2Frose-phas%2F</url>
    <content type="text"><![CDATA[GetSpecificLengthReads12java jsmallrna.util.GetSpecificLengthReads -i /mnt/S30/guojq/rose/rose-data/rose-tissue-freq-seq.fa -l 24 -o rose-24seq.fajava jsmallrna.util.GetSpecificLengthReads -i /mnt/S30/guojq/rose/rose-data/rose-tissue-freq-seq.fa -l 21 -o rose-21seq.fa get-unrepeats-seq1234567891011121314151617181920212223242526# 1. This is to align degradome (I think 'degradome' should be changed to 'tissue-freq.fa') reads to tigr-repeats with SOAP2.foreach FA(*.fa)soap -a $FA -D /mnt/S30/database/repbase/tigr-repeats.fa.index -o `\basename $FA .fa`-vs-repeats.soap -M 0 -r 2grep '&gt;' $FA | cut -f 1 &gt; `\basename $FA .fa`-ids1.txtsed 's/&gt;//g' `\basename $FA .fa`-ids1.txt &gt; `\basename $FA .fa`-ids2.txtend# 2. This is to get the mapped sequence.foreach SOAP(*.soap)java jsmallrna.soap.GetMappedSeqSoap -i $SOAP -s $FA -S both -o `\basename $SOAP .soap`.fasta -l 18 -m 0end# 3. This is to get the ids of mapped sequence.foreach FASTA(*.fasta)grep '&gt;' $FASTA | cut -f 1 &gt; `\basename $FASTA .fasta`-ids1.txtsed 's/&gt;//g' `\basename $FASTA .fasta`-ids1.txt &gt; `\basename $FASTA .fasta`-ids2.txtend# 4. This is to get the first column of ids2.foreach IDS2(*-ids2.txt)cut -f 1 -d " " $IDS2 &gt; `\basename $IDS2 -ids2.txt`-ids.txtend# 5. get not mapped ids.cat *-ids.txt &gt; seq-plus-repeats.txtsort seq-plus-repeats.txt | uniq -d &gt; seq-intersect-repeats.txtcat seq-intersect-repeats.txt *seq-ids.txt &gt; seq-plus-intersect.txtsort seq-plus-intersect.txt | uniq -u &gt; seq-unrepeats-ids.txt# 6. get not mapped seq.java jsmallrna.util.RetrieveSpecifiedReads -i *seq.fa -n seq-unrepeats-ids.txt -o seq-unrepeats-seq.fa -t 1 build index for cdna12bwt-builder rose-cdna.fa get phas1234567891011121314151617#1.soap.shsoap -a ../seq-unrepeats-seq.fa -D /mnt/S30/guojq/rose/rose-phas/rose-cdna.fa.index -o rose-21nt-vs-cds.soap -M 0 -r 2#2.sort-soap.shforeach SOAP (*.soap)sort -k 8 $SOAP &gt; `\basename $SOAP .soap`.sortedend#3getMappedSeq.shforeach SORTED (*.sorted)java jsmallrna.soap.GetMappedSeqSoap -i $SORTED -s ../seq-unrepeats-seq.fa -S both -o `\basename $SORTED .sorted`.fa -l 18 -m 0end#4get-phas.shforeach SORTED (*.sorted)java -Xmx600g jsmallrna.sirna.PhasiRNAFinderTree -i $SORTED -r `\basename $SORTED .sorted`.fa -t `\basename $SORTED .sorted`-summary.txt -o `\basename $SORTED .sorted`-phas.fa -b /mnt/S30/guojq/rose/rose-data/calc-freq/rose-barcodes.txt -c /mnt/S30/guojq/rose/rose-phas/rose-cdna.fa -d `\basename $SORTED .sorted`-vs-reads.bedgragh -p 10 -l 21 -s 5end]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[methDiffRegion]]></title>
    <url>%2FmethDiffRegion%2F</url>
    <content type="text"><![CDATA[bismark处理测序数据: 对拟南芥基因组建索引 12bismark_genome_preparation --verbose --bowtie2 /mnt/S30/guojq/methylation/genome /*将tair10.fa放到/mnt/S30/guojq/methylation/genome文件夹，bismark会在这个目录下建立索引，之后使用该路径调用索引文件*/ bismark处理测序数据 12345678bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/CIBC-CK1/CIBC-CK1_1.fq -2 /mnt/S30/guojq/methylation/data/CIBC-CK1/CIBC-CK1_2.fq -o ./CIBC-CK1 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/CIBC-CK2/CIBC-CK2_1.fq -2 /mnt/S30/guojq/methylation/data/CIBC-CK2/CIBC-CK2_2.fq -o ./CIBC-CK2 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/CIBC-DT1/CIBC-DT1_1.fq -2 /mnt/S30/guojq/methylation/data/CIBC-DT1/CIBC-DT1_2.fq -o ./CIBC-DT1 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/CIBC-DT2/CIBC-DT2_1.fq -2 /mnt/S30/guojq/methylation/data/CIBC-DT2/CIBC-DT2_2.fq -o ./CIBC-DT2 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/BURO-CK1/BURO-CK1_1.fq -2 /mnt/S30/guojq/methylation/data/BURO-CK1/BURO-CK1_2.fq -o ./BURO-CK1 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/BURO-CK2/BURO-CK2_1.fq -2 /mnt/S30/guojq/methylation/data/BURO-CK2/BURO-CK2_2.fq -o ./BURO-CK2 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/BURO-DT1/BURO-DT1_1.fq -2 /mnt/S30/guojq/methylation/data/BURO-DT1/BURO-DT1_2.fq -o ./BURO-DT1 &amp;bismark -p 5 /mnt/S30/guojq/methylation/genome --bowtie2 -1 /mnt/S30/guojq/methylation/data/BURO-DT2/BURO-DT2_1.fq -2 /mnt/S30/guojq/methylation/data/BURO-DT2/BURO-DT2_2.fq -o ./BURO-DT2 methylKit分析甲基化差异性表达 对bismark生成的bam文件排序，转化为sam文件，命令: 1234foreach BAM(*_pe.bam)samtools sort $BAM `\basename $BAM .bam`.sortedsamtools view -h `\basename $BAM .bam`.sorted.bam &gt; `\basename $BAM .bam`.sorted.samend 根据sam文件提取甲基化信息，命令如下: 1234567library(methylKit)fns=Sys.glob('*.sam')for(fn in fns)&#123; wri_f=paste( strsplit( fn, '_1_bismark_bt2_pe.sorted.sam', fixed=T )[[1]][1] ,'', sep='') myobj=read.bismark(fn,wri_f,assembly="tair10",save.context="CpG",read.context="CpG",save.fold=getwd()) &#125; read.bismark是methylKit自带的一个方法，可以提取CpG、CHG、CHH甲基化水平，生成包含甲基化水平的txt文件，格式如下： chrBase chr base strand coverage freqC Chr1.500 Chr1 500 F 20 0.00 Chr1.511 Chr1 511 F 22 0.00 根据甲基化水平文件，生成bedGraph文件 123456789library(methylKit)fns=Sys.glob('*.txt') for(fn in fns)&#123; wri_f=paste( strsplit( fn, '_CpG.txt', fixed=T )[[1]][1] , '', sep='') myobj=methRead(fn,wri_f,"tair10") wri_f=paste( strsplit( fn, '.txt', fixed=T )[[1]][1] , '.bedgraph', sep='') bedgraph(myobj,wri_f,col.name="perc.meth",unmeth=FALSE,log.transform=FALSE,negative=FALSE,add.on="") &#125; 根据甲基化水平文件，计算甲基化差异，找差异表达区域 12345678910111213141516171819202122library(methylKit)file.list1 &lt;- list("BURO-CK1_CpG.txt","BURO-CK2_CpG.txt","BURO-DT1_CpG.txt","BURO-DT2_CpG.txt") file.list2 &lt;- list("CIBC-CK1_CpG.txt","CIBC-CK2_CpG.txt","CIBC-DT1_CpG.txt","CIBC-DT2_CpG.txt")objs1 &lt;- methRead(file.list1,sample.id=list("BURO-CK1","BURO-CK2","BURO-DT1","BURO-DT2"),assembly="tair10",treatment=c(0,0,1,1))objs2 &lt;- methRead(file.list2,sample.id=list("CIBC-CK1","CIBC-CK2","CIBC-DT1","CIBC-DT2"),assembly="tair10",treatment=c(0,0,1,1))regionCounts1 &lt;- tileMethylCounts(objs1 , win.size = 500,step.size = 500)regionCounts2 &lt;- tileMethylCounts(objs2 , win.size = 500,step.size = 500)meth1 &lt;- unite(regionCounts1)meth2 &lt;- unite(regionCounts2)write.table(meth1,"BURO-regionCounts.txt",sep="\t",row.names=FALSE,col.names=TRUE)write.table(meth2,"CIBC-regionCounts.txt",sep="\t",row.names=FALSE,col.names=TRUE)diff1 &lt;- calculateDiffMeth(meth1)diff2 &lt;- calculateDiffMeth(meth2)myDiff1.hyper &lt;- getMethylDiff(diff1,difference=25,qvalue=0.01,type="hyper")myDiff1.hypo &lt;- getMethylDiff(diff1,difference=25,qvalue=0.01,type="hypo")write.table(myDiff1.hyper,"BURO-hyper-diff-region.txt",sep="\t",row.names=FALSE,col.names=TRUE)write.table(myDiff1.hypo,"BURO-hypo-diff-region.txt",sep="\t",row.names=FALSE,col.names=TRUE)myDiff2.hyper &lt;- getMethylDiff(diff2,difference=25,qvalue=0.01,type="hyper")myDiff2.hypo &lt;- getMethylDiff(diff2,difference=25,qvalue=0.01,type="hypo"))write.table(myDiff2.hyper,"CIBC-hyper-diff-region.txt",sep="\t",row.names=FALSE,col.names=TRUE)write.table(myDiff2.hypo,"CIBC-hypo-diff-region.txt",sep="\t",row.names=FALSE,col.names=TRUE]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>bismark</tag>
        <tag>methylKit</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gff2bed]]></title>
    <url>%2Fgff2bed%2F</url>
    <content type="text"><![CDATA[BED 文件格式提供了一种灵活的方式来定义的数据行，以用来描述注释的信息。BED行有3个必须的列和9个额外可选的列。 每行的数据格式要求一致。通常所见的bed文件为6列，但是一些软件要求输入12列bed文件(UCSC Genome Browser)，通过探索研究出一下两种从gff3/gtf转为12列bed文件的方法。 GFFtools-GXGFFtools-GX是vipints分享在GitHub上的一个程序集，里面包含了gff、gtf、gbk、bed格式之间的相互转换。 在GitHub上，vipints分享了一种使用方式，该方式需要在本地先配置Galaxy Tool shed(具体配置看网站说明，并安装了python2.6或者2.7以及biopython。配置完成后，使用一下命令调用该软件包: 1sh run_functional_tests.sh -id fml_gtf2gff 另一种方式是将软件包下载下来，直接调用软件包中的脚本 123#Convert genome annotation data in GFF/GTF to a 12 column BED format. BED format typically represents the transcript models. Usage: python gff_to_bed.py in.gff &gt; out.bed python gtf_to_bed.py in.gtf &gt; out.bed 直接下载的软件包中的gff_to_bed.py在运行时会出现以下报错，1TypeError: len() of unsized object 在GitHub上tzintzuni给出了解决方法，修改gff_to_bed.py文件，将以下代码1234567891011121314151617181920212223242526def writeBED(tinfo): """ writing result files in bed format @args tinfo: list of genes @type tinfo: numpy object """ for ent1 in tinfo: child_flag = False for idx, tid in enumerate(ent1['transcripts']): child_flag = True exon_cnt = len(ent1['exons'][idx]) exon_len = '' exon_cod = '' rel_start = None rel_stop = None for idz, ex_cod in enumerate(ent1['exons'][idx]):#check for exons of corresponding transcript exon_len += '%d,' % (ex_cod[1]-ex_cod[0]+1) if idz == 0: #calculate the relative start position exon_cod += '0,' rel_start = int(ex_cod[0])-1 rel_stop = int(ex_cod[1]) else: exon_cod += '%d,' % (ex_cod[0]-1-rel_start) ## shifting the coordinates to zero rel_stop = int(ex_cod[1]) 替换为1234567891011121314151617181920212223242526272829def writeBED(tinfo): """ writing result files in bed format @args tinfo: list of genes @type tinfo: numpy object """ for ent1 in tinfo: child_flag = False for idx, tid in enumerate(ent1['transcripts']): child_flag = True exon_cnt = 0 exon_len = '' exon_cod = '' rel_start = None rel_stop = None if ent1['exons'][idx].ndim &gt; 0: exon_cnt = len(ent1['exons'][idx]) for idz, ex_cod in enumerate(ent1['exons'][idx]):#check for exons of corresponding transcript exon_len += '%d,' % (ex_cod[1]-ex_cod[0]+1) if idz == 0: #calculate the relative start position exon_cod += '0,' rel_start = int(ex_cod[0])-1 rel_stop = int(ex_cod[1]) else: exon_cod += '%d,' % (ex_cod[0]-1-rel_start) ## shifting the coordinates to zero rel_stop = int(ex_cod[1]) 修改后运行脚本，出现以下错误:12 将脚本末尾以下部分代码:123out_print = [ent1['chr'], '%d' % int(ent1['start'])-1, '%d' % int(ent1['stop']), 修改为:123out_print = [ent1['chr'], '%d' % (int(ent1['start'])-1), '%d' % int(ent1['stop']), 即可解决问题。 BEDOPSBEDOPS包含了多种工具，最常用的就是convert2bed，可将方便的将gff、gtf、bam等多种格式转换为bed或者starch格式，但在转换为12列bed文件时需要借助UCSC提供的软件包来完成。下载需要的UCSC包:12345#可浏览网址http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/ 查看各种包wget -c http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/gff3ToGenePredwget -c http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/gtfToGenePredwget -c http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/genePredToBedchmod 755 gff3ToGenePred gtfToGenePred genePredToBed 转换gtf文件为bed12:1gtfToGenePred test.gtf test.genePhred &amp;&amp; genePredToBed test.genePhred result.bed &amp;&amp; rm test.genePhred 转换gff文件为bed12:1gtf3ToGenePred test.gff test.genePhred &amp;&amp; genePredToBed test.genePhred result.bed &amp;&amp; rm test.genePhred 如有问题，欢迎交流。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>gfftools</tag>
      </tags>
  </entry>
</search>
